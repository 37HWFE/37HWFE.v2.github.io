<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><title>http 文件缓存机制 | Ocean Team Blog</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="Ocean Team Blog"><meta name="description" content="Ocean Team Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://www.37oct.cn/2021/02/20/http-memory-cache/index.html"><link rel="icon" type="image/png" href="/img/logo.png" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Ocean Team Blog" type="application/atom+xml"><link rel="stylesheet" href="/scss/views/page/post.css"><meta name="generator" content="Hexo 5.3.0"></head><body ontouchstart><div id="page-loading" class="page page-loading"><div class="wrap"><div class="k-line k-line11-1"></div><div class="k-line k-line11-2"></div><div class="k-line k-line11-3"></div><div class="k-line k-line11-4"></div><div class="k-line k-line11-5"></div></div></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Ocean Team Blog" alt="Ocean Team Blog"><img src="/img/logo.png" alt="Ocean Team Blog"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/2021/http-memory-cache/cover.png" alt="http 文件缓存机制"></div><header class="post__info"><h1 class="post__title">http 文件缓存机制</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.37oct.cn/">oceanTeam</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2021-02-20</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/">前端性能</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h4 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h4><p>1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。<br>在network中，能抓到请求的情况，强制缓存的状态码是 status:灰色的200. size : from memory cache<br><img src="/images/2021/http-memory-cache/1.png" alt="缓存请求"></p><center><font color="#777" size="3">图1：缓存请求</font></center><p><img src="/images/2021/http-memory-cache/%E7%81%B0%E8%89%B2%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98.png" alt="状态码灰色两百，不一定是读取缓存"></p><center><font color="#777" size="3">图2：状态码灰色两百，不一定是读取缓存</font></center><p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回304，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p><img src="/images/2021/http-memory-cache/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%B1%95%E7%A4%BA.png" alt="图3：强缓存"></p><center><font color="#777" size="3">图3：强缓存</font></center><h5 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h5><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header<br>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；<br>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。<br>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p><p><img src="/images/2021/http-memory-cache/expire%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="expire缓存过程"></p><center><font color="#777" size="3">图4：expire缓存过程</font></center><h5 id="cache-Control"><a href="#cache-Control" class="headerlink" title="cache-Control"></a>cache-Control</h5><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p><p><img src="/images/2021/http-memory-cache/cache-control%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="cache-control缓存过程"></p><center><font color="#777" size="3">图5：cache-control缓存过程</font></center><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header<br>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；<br>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。<br>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串</p><p><strong>首次访问的响应头</strong></p><p><img src="/images/2021/http-memory-cache/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="首次访问的响应头"></p><center><font color="#777" size="3">图6：首次访问的响应头</font></center><p><strong>第二次访问的请求头</strong></p><p><img src="/images/2021/http-memory-cache/modifile%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="第二次访问的请求头"></p><center><font color="#777" size="3">图7：第二次访问的请求头</font></center><p><strong>第二次请求响应头</strong></p><p><img src="/images/2021/http-memory-cache/modifile%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="第二次请求响应头"></p><center><font color="#777" size="3">图8：第二次请求响应头</font></center><h5 id="Last-Modified，If-Modified-Since"><a href="#Last-Modified，If-Modified-Since" class="headerlink" title="Last-Modified，If-Modified-Since"></a>Last-Modified，If-Modified-Since</h5><p><img src="/images/2021/http-memory-cache/modifile%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="Last-Modified请求过程"></p><center><font color="#777" size="3">图9：modifiled 请求过程</font></center><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</p><p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。</p><p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</p><p>浏览器收到304的响应后，就会从缓存中加载资源。</p><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p><h5 id="ETag、If-None-Match"><a href="#ETag、If-None-Match" class="headerlink" title="ETag、If-None-Match"></a>ETag、If-None-Match</h5><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p><p><img src="/images/2021/http-memory-cache/etag%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="etag请求过程"></p><center><font color="#777" size="3">图9：modifiled 请求过程</font></center><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p><p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：</p><p>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化</p><p>浏览器收到304的响应后，就会从缓存中加载资源。</p><h4 id="以下行为可能改变缓存的默认处理方式"><a href="#以下行为可能改变缓存的默认处理方式" class="headerlink" title="以下行为可能改变缓存的默认处理方式"></a>以下行为可能改变缓存的默认处理方式</h4><p>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p><p>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://www.37oct.cn">Ocean Team Blog</a> 版权所有。如若转载，请注明出处：Ocean Team Blog（<a href="/2021/02/20/http-memory-cache/">https://www.37oct.cn/2021/02/20/http-memory-cache/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2021/02/20/body-background-color-setting/" title="HTML/BODY背景渲染原理"><i class="iconfont icon-prev"></i>HTML/BODY背景渲染原理</a></div><div class="post__prev post__prev--right"></div></div></div></article><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">Ocean Team Blog</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7/">资源工具</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/JavaScript/">JavaScript</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/CSS3/">CSS3</a><span class="block-list-count">1</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2021/02/20/http-memory-cache/" title="http 文件缓存机制"><div class="item__cover"><img src="/images/2021/http-memory-cache/cover.png" alt="http 文件缓存机制"></div><div class="item__info"><h3 class="item__title">http 文件缓存机制</h3><span class="item__text">2021-02-20</span></div></a></li><li class="latest-post-item"><a href="/2021/02/20/body-background-color-setting/" title="HTML/BODY背景渲染原理"><div class="item__cover"><img src="/images/2021/body-background-color-setting/cover.png" alt="HTML/BODY背景渲染原理"></div><div class="item__info"><h3 class="item__title">HTML/BODY背景渲染原理</h3><span class="item__text">2021-02-20</span></div></a></li><li class="latest-post-item"><a href="/2021/02/20/auto-ps-cut-image-function/" title="解放双手-ps自动切图脚本"><div class="item__cover"><img src="/images/2021/auto-ps-cut-image-function/cover.png" alt="解放双手-ps自动切图脚本"></div><div class="item__info"><h3 class="item__title">解放双手-ps自动切图脚本</h3><span class="item__text">2021-02-20</span></div></a></li><li class="latest-post-item"><a href="/2021/02/20/what-is-react/" title="当我们谈论React时，我们谈论些什么？"><div class="item__cover"><img src="/images/2021/what-is-react/cover.png" alt="当我们谈论React时，我们谈论些什么？"></div><div class="item__info"><h3 class="item__title">当我们谈论React时，我们谈论些什么？</h3><span class="item__text">2021-02-20</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Background/">Background</a></li><li class="tag-item"><a class="tag-link" href="/tags/CSS/">CSS</a></li><li class="tag-item"><a class="tag-link" href="/tags/HTML/">HTML</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/React/">React</a></li><li class="tag-item"><a class="tag-link" href="/tags/ps%E8%87%AA%E5%8A%A8%E5%88%87%E5%9B%BE/">ps自动切图</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/">前端性能</a></li><li class="tag-item"><a class="tag-link" href="/tags/%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7/">资源工具</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">主要用于分享37海外前端Ocean团队日常学习、交流、输出</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Guangzhou, Guangdong Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>zhouguilin@gm99.com</span></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/page/post.js"></script><script>var disqus_shortname="oceanteam",disqus_config=function(){this.page.url="https://www.37oct.cn/2021/02/20/http-memory-cache/",this.page.identifier="/2021/02/20/http-memory-cache/",this.page.title="http 文件缓存机制"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/common/utils.js"></script><script src="/js/common/pack.js"></script><script src="/js/common/animation.js"></script><script src="/js/layout/loading.js"></script><script src="/js/layout/header.js"></script><script src="/js/layout/back-top.js"></script><script src="/js/layout/post.js"></script></body></html>