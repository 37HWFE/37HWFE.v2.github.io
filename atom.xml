<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ocean Team Blog</title>
  
  <subtitle>Ocean Team Blog</subtitle>
  <link href="https://www.37oct.cn/atom.xml" rel="self"/>
  
  <link href="https://www.37oct.cn/"/>
  <updated>2021-03-11T06:10:42.585Z</updated>
  <id>https://www.37oct.cn/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>http 文件缓存机制</title>
    <link href="https://www.37oct.cn/2021/02/20/http-memory-cache/"/>
    <id>https://www.37oct.cn/2021/02/20/http-memory-cache/</id>
    <published>2021-02-20T07:01:22.000Z</published>
    <updated>2021-03-11T06:10:42.585Z</updated>
    
    <content type="html"><![CDATA[<h4 id="强缓存与协商缓存"><a href="#强缓存与协商缓存" class="headerlink" title="强缓存与协商缓存"></a>强缓存与协商缓存</h4><p>1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。<br>在network中，能抓到请求的情况，强制缓存的状态码是 status:灰色的200.  size :  from memory cache<br><img src="/images/2021/http-memory-cache/1.png" alt="缓存请求"></p><center><font color="#777" size="3">图1：缓存请求</font></center><p><img src="/images/2021/http-memory-cache/%E7%81%B0%E8%89%B2%E4%B8%8D%E4%B8%80%E5%AE%9A%E6%98%AF%E8%AF%BB%E5%8F%96%E7%BC%93%E5%AD%98.png" alt="状态码灰色两百，不一定是读取缓存"></p><center><font color="#777" size="3">图2：状态码灰色两百，不一定是读取缓存</font></center><p>2）当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些http header验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回304，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p> <img src="/images/2021/http-memory-cache/%E5%BC%BA%E7%BC%93%E5%AD%98%E5%B1%95%E7%A4%BA.png" alt="图3：强缓存"></p><center><font color="#777" size="3">图3：强缓存</font></center><h5 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h5><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header<br>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；<br>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行。<br>如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。</p><p><img src="/images/2021/http-memory-cache/expire%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="expire缓存过程"></p><center><font color="#777" size="3">图4：expire缓存过程</font></center><h5 id="cache-Control"><a href="#cache-Control" class="headerlink" title="cache-Control"></a>cache-Control</h5><p>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000，它的缓存原理是：</p><p><img src="/images/2021/http-memory-cache/cache-control%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.png" alt="cache-control缓存过程"></p><center><font color="#777" size="3">图5：cache-control缓存过程</font></center><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header<br>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；<br>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。<br>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串</p><p><strong>首次访问的响应头</strong></p><p><img src="/images/2021/http-memory-cache/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="首次访问的响应头"></p><center><font color="#777" size="3">图6：首次访问的响应头</font></center><p><strong>第二次访问的请求头</strong></p><p><img src="/images/2021/http-memory-cache/modifile%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="第二次访问的请求头"></p><center><font color="#777" size="3">图7：第二次访问的请求头</font></center><p><strong>第二次请求响应头</strong></p><p><img src="/images/2021/http-memory-cache/modifile%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="第二次请求响应头"></p><center><font color="#777" size="3">图8：第二次请求响应头</font></center><h5 id="Last-Modified，If-Modified-Since"><a href="#Last-Modified，If-Modified-Since" class="headerlink" title="Last-Modified，If-Modified-Since"></a>Last-Modified，If-Modified-Since</h5><p><img src="/images/2021/http-memory-cache/modifile%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%93%8D%E5%BA%94%E5%A4%B4.png" alt="Last-Modified请求过程"></p><center><font color="#777" size="3">图9：modifiled 请求过程</font></center><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</p><p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。</p><p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</p><p>浏览器收到304的响应后，就会从缓存中加载资源。</p><p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p><h5 id="ETag、If-None-Match"><a href="#ETag、If-None-Match" class="headerlink" title="ETag、If-None-Match"></a>ETag、If-None-Match</h5><p>【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。它们的缓存管理的方式是：</p><p><img src="/images/2021/http-memory-cache/etag%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt="etag请求过程"></p><center><font color="#777" size="3">图9：modifiled 请求过程</font></center><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题：</p><p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值：</p><p>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化</p><p>浏览器收到304的响应后，就会从缓存中加载资源。</p><h4 id="以下行为可能改变缓存的默认处理方式"><a href="#以下行为可能改变缓存的默认处理方式" class="headerlink" title="以下行为可能改变缓存的默认处理方式"></a>以下行为可能改变缓存的默认处理方式</h4><p>当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p><p>当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;强缓存与协商缓存&quot;&gt;&lt;a href=&quot;#强缓存与协商缓存&quot; class=&quot;headerlink&quot; title=&quot;强缓存与协商缓存&quot;&gt;&lt;/a&gt;强缓存与协商缓存&lt;/h4&gt;&lt;p&gt;1）浏览器在加载资源时，先根据这个资源的一些http header判断它是否命中强缓存，强缓</summary>
      
    
    
    
    <category term="前端知识" scheme="https://www.37oct.cn/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端性能" scheme="https://www.37oct.cn/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>HTML/BODY背景渲染原理</title>
    <link href="https://www.37oct.cn/2021/02/20/body-background-color-setting/"/>
    <id>https://www.37oct.cn/2021/02/20/body-background-color-setting/</id>
    <published>2021-02-20T06:46:31.000Z</published>
    <updated>2021-03-11T06:10:42.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p><font color="#f66"><strong>结论先行：</strong></font></p><p>我们给body设置背景色，实际我们看见的未必是body上的背景色：</p><ol><li><font color="#42b983">当html标签没有设置背景色时，我们看见的是作用在浏览器画布上的背景色，不是body上的；</li><li>当html标签被设置了背景色时，我们看见的是真正作用在body上的背景色。</font></li></ol><p>人在前端已经漂泊数年，机缘巧合才发现，这几年给body写的背景色，全被浏览器给「吃」了。文中涉及的是<font color="#42b983">CSS中关于特殊元素（html/body）的背景渲染的原理</font>，对你而言它也许是块新大陆，也可能，你早已熟知，那么正好···可以一起交流下？</p><h3 id="二、一个情景"><a href="#二、一个情景" class="headerlink" title="二、一个情景"></a>二、一个情景</h3><p>有一个渲染列表的页面（不定高），要求<font color="#f66">背景是渐变颜色</font>，效果如下图：<br><img src="https://user-gold-cdn.xitu.io/2018/5/29/163ac1f6e90bdee3?w=1160&h=652&f=jpeg&s=43504"><br><strong>需求很简单：</strong></p><ul><li>列表内容不足以撑满一屏时，整屏背景以渐变色填充；</li><li>列表内容超过一屏高度时，整个页面背景以渐变色填充；</li></ul><h3 id="三、情景破解"><a href="#三、情景破解" class="headerlink" title="三、情景破解"></a>三、情景破解</h3><p><font color="#f66">姿势有很多，偏爱的只有妳这一种。</font></p><p>PS：破解情景的解法有很多，而下面这种解法可以引起我们关于html、body背景渲染原理的思考。</p><h5 id="Step-1：首先给body设置颜色渐变"><a href="#Step-1：首先给body设置颜色渐变" class="headerlink" title="Step 1：首先给body设置颜色渐变"></a>Step 1：首先给body设置颜色渐变</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(#FFFAD0,#ffffff); &#125;</span><br></pre></td></tr></table></figure><p>不出意外，页面渐变出现了断层👇<br><img src="https://user-gold-cdn.xitu.io/2018/5/29/163ac28b30125a81?w=1156&h=652&f=jpeg&s=45796"></p><h5 id="Step-2：设置html高度为100-，同时给body设置下min-height"><a href="#Step-2：设置html高度为100-，同时给body设置下min-height" class="headerlink" title="Step 2：设置html高度为100%，同时给body设置下min-height"></a>Step 2：设置html高度为100%，同时给body设置下min-height</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>;&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">min-height</span>: <span class="number">100%</span>; <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(#FFFAD0,#ffffff); &#125;</span><br></pre></td></tr></table></figure><p>又不出意外，看起来很OJBK，没有出现断层了！</p><p>突然，内容渐渐多了起来，超过一屏的高度了···👇<br><img src="https://user-gold-cdn.xitu.io/2018/5/29/163ac2dfb7e1e4fe?w=1156&h=648&f=jpeg&s=62578"></p><p>呃···这是什么情况？超过一屏之后又断层了！[what the fuck &amp; 掀桌].jpg</p><h5 id="Step3：设置html的背景色"><a href="#Step3：设置html的背景色" class="headerlink" title="Step3：设置html的背景色"></a>Step3：设置html的背景色</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>; <span class="attribute">background</span>: red; &#125;</span><br></pre></td></tr></table></figure><p>是的，你没看错，我给html设置了红色！不得不服气，这样的骚操作竟然解决了上面断层的问题。</p><h5 id="突然兴起的总结"><a href="#突然兴起的总结" class="headerlink" title="突然兴起的总结"></a>突然兴起的总结</h5><p><font color="#f66"><strong>小小梳理下我们遇到的疑点：</strong></font></p><ol><li>首先我们给body设置了渐变色，即使内容超过一屏，我们看到的也应该是body那一层，即是渐变色的背景，不应该断层！</li><li>为什么给html元素设置一个背景色就可以完美解决这个断层？</li></ol><h3 id="四、原理解析"><a href="#四、原理解析" class="headerlink" title="四、原理解析"></a>四、原理解析</h3><p>我们这个问题涉及到了三个对象：<font color="#42b983">html元素、body元素和浏览器画布</font>，我们需要了解它们三者之间渲染背景色的机制。</p><blockquote><p>The document canvas is the infinite surface over which the document is rendered. [CSS2] Since no element corresponds to the canvas, in order to allow styling of the canvas CSS propagates the background of the root element (or, in the case of HTML, the <body> element) as described below. However, if no boxes are generated for the element whose background would be used for the canvas (for example, if the root element has display: none), then the canvas background is transparent.</p></blockquote><blockquote><p>The background of the root element becomes the background of the canvas and its background painting area extends to cover the entire canvas. However, any images are sized and positioned relative to the root element as if they were painted for that element alone. (In other words, the background positioning area is determined as for the root element.) The root element does not paint this background again, i.e., the used value of its background is transparent.</p></blockquote><p>以上是w3c对特定元素（根元素）背景的定义说明，总结为以下两点：</p><ul><li><font color="#42b983">CSS根据根元素（html/body）给文档画布（该画布是无限大的，我们姑且理解为浏览器画布）渲染背景颜色，同时背景色的定位区域就是根元素的区域；</li><li>根元素不再绘制该背景色，即根元素背景的使用值是透明的。</font></li></ul><p>基于这两点解答前面我们的疑问：</p><h5 id="1、给body设置了渐变色背景，内容超过一屏的时候，出现了断层"><a href="#1、给body设置了渐变色背景，内容超过一屏的时候，出现了断层" class="headerlink" title="1、给body设置了渐变色背景，内容超过一屏的时候，出现了断层"></a>1、给body设置了渐变色背景，内容超过一屏的时候，出现了断层</h5><p>真相是，浏览器画布首先获取根节点的背景样式，由于html我们没有设置，所以它获取了body的背景色，从而导致浏览器画布也是渐变色背景；</p><p>其次，浏览器画布背景色的定位区域取决于根元素的区域，这里的根元素是html，而我们对html做了 height:100% 的设置。所以浏览器画布以该区域的背景色重复渲染。</p><p>用图举证：<br>给html设置50%的width，那么左侧看到的是我们的页面dom内容，右侧则是浏览器画布</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>; <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123; <span class="attribute">min-height</span>: <span class="number">100%</span>; <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(#FFFAD0,#ffffff); &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/5/30/163aecafb284ec93?w=1158&h=650&f=jpeg&s=51375"><br>可以发现，左右两侧的背景色是一致的：<br><img src="https://user-gold-cdn.xitu.io/2018/5/30/163aeceb4cbf2782?w=1156&h=654&f=jpeg&s=63084"><br><font color="#f66">证明了浏览器画布取了body的背景色进行渲染，而body的背景色其实是透明值，必然地，我们在body看见的是会断层的渐变色。</font></p><p><font color="#f66"><strong>所以，我们给body设置的背景色被浏览器画布吃掉了!</strong></font></p><h5 id="2、通过html设置背景色的方式解决了断层问题"><a href="#2、通过html设置背景色的方式解决了断层问题" class="headerlink" title="2、通过html设置背景色的方式解决了断层问题"></a>2、通过html设置背景色的方式解决了断层问题</h5><p>我们给html设置背景色，其实是<font color="#f66">让html去承担被浏览器画布取色的任务，这时候body的值就是我们设置的渐变色</font>。以图举证：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>; <span class="attribute">width</span>: <span class="number">50%</span>; <span class="attribute">background</span>: <span class="number">#42b983</span>; &#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/5/30/163aed8393d1d212?w=1160&h=652&f=jpeg&s=61155"><br>对的，红色不喜欢，我决定了换成vue的主题绿。如此，浏览器画布取了html的背景色，左侧就可以正常看见body的渐变背景了。</p><h3 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h3><p>以上提及的知识点也许很基础，它只是w3c里面关于背景渲染的标准，只不过被我们很多人忽略而已。现在踩坑，记之共勉。</p><p><strong>原文链接：</strong><a href="https://juejin.im/post/5b0d52e5f265da092918d902">天呐！我给body设置的背景色被浏览器吃掉了！</a></p><p><strong>参考</strong></p><p><a href="https://stackoverflow.com/questions/10947541/applying-a-background-to-html-and-or-body">Applying a background to <html> and/or <body></a></p><p><a href="https://www.w3.org/TR/css-backgrounds-3/#special-backgrounds">Backgrounds of Special Elements</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;&lt;font color=&quot;#f66&quot;&gt;&lt;strong&gt;结论先行：&lt;/strong&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;我们给bod</summary>
      
    
    
    
    <category term="CSS3" scheme="https://www.37oct.cn/categories/CSS3/"/>
    
    
    <category term="CSS" scheme="https://www.37oct.cn/tags/CSS/"/>
    
    <category term="Background" scheme="https://www.37oct.cn/tags/Background/"/>
    
    <category term="HTML" scheme="https://www.37oct.cn/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>解放双手-ps自动切图脚本</title>
    <link href="https://www.37oct.cn/2021/02/20/auto-ps-cut-image-function/"/>
    <id>https://www.37oct.cn/2021/02/20/auto-ps-cut-image-function/</id>
    <published>2021-02-20T06:46:00.000Z</published>
    <updated>2021-03-11T06:10:42.584Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>为什么会做这个呢？大概是因为小编我是一个“懒”到不想切图的程序员吧……某一天听说隔壁部门的大佬有这个想法，然后就自己也摆弄一下下。</p><h4 id="说说ps脚本"><a href="#说说ps脚本" class="headerlink" title="说说ps脚本"></a>说说ps脚本</h4><p>ps脚本的设计目的，主要是为了辅助设计师们设计的。所有的脚本操作都必须基于一点：你必须得打开photoshop，然后看着它自己进行各种骚操作……所以我在国内的网站搜资料，找到的比较多的是【教设计师如何用脚本简化设计操作】这一类的教程。后来只好去看英文的开发文档photoshop文档（然而小编英文好不……），后来再翻了翻发现一些可以辅助的中文网站，如<a href="http://nullice.com/archives/1790#">http://nullice.com/archives/1790#</a></p><h4 id="捋捋实现思路"><a href="#捋捋实现思路" class="headerlink" title="捋捋实现思路"></a>捋捋实现思路</h4><p>小编在网上看到一个例子，它的实现思路如下：<br><img src="/images/2021/auto-ps-cut-image-function/1.png" alt="iphone各机型的规格"><br>小编认为，频繁的新建／删除文件的操作是不必要的。但如果不新建文件操作，直接修改原psd的画布大小，又有其他图层干扰。所以就优化了一下，下面是小编最终脚本实现思路：<br><img src="/images/2021/auto-ps-cut-image-function/2.png" alt="iphone各机型的规格"><br>想想为什么要处理图层<br>原因有三：其一，小编收到的psd一般比较复杂，有些地方需要做一些处理才能导出；其二，为了减少图层，避免卡机；其三，文件夹无法复制（没有复制的api），图层的话，可见图层可以复制，但不可见的，或者是文字图层、形状图层等非常规图层无法复制</p><h4 id="写写代码"><a href="#写写代码" class="headerlink" title="写写代码"></a>写写代码</h4><p>步骤一：首先你的知道导出的图片要存在哪里<br>可以选择写死路径，当然更人性化的就是调个弹窗出来让用户自己选择嘛～</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 保存用户选择的文件夹路径</span><br><span class="line">var outputFolder = Folder.selectDialog(<span class="string">&#x27;请选择输出文件夹&#x27;</span>);</span><br></pre></td></tr></table></figure><p>步骤二：处理图层<br>这里可以根据自己的需要去写逻辑，小编的处理逻辑是：【如果组里没有组，就把这个图合并】。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">// 保存需要合并的组</span><br><span class="line">var mergeGroupArr = [];</span><br><span class="line">// 保存需要移动的图层</span><br><span class="line">var moveLayerArr = [];</span><br><span class="line">// 特殊字符</span><br><span class="line">var ISBG = <span class="string">&#x27;bg&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">// 处理图层</span><br><span class="line">dealLayer(app.activeDocument.layerSet);</span><br><span class="line"> </span><br><span class="line">// 处理图层</span><br><span class="line"><span class="keyword">function</span> dealLayer(groups) &#123;</span><br><span class="line">    // 寻找组中需要合并的组</span><br><span class="line">    findNestGroup(app.activeDocument.layerSets, getNeedMergeGroup);</span><br><span class="line">    // 合并组</span><br><span class="line">    mergeGroup(mergeGroupArr);</span><br><span class="line">    // 寻找组中需要移动的图层</span><br><span class="line">    findNestGroup(app.activeDocument.layerSets, getMoveLayer, getMoveLayer);</span><br><span class="line">    // 移动图层</span><br><span class="line">    moveLayer(moveLayerArr);</span><br><span class="line">    // 删除所有组</span><br><span class="line">    app.activeDocument.layerSets.removeAll();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 查找组中组</span><br><span class="line"><span class="keyword">function</span> findNestGroup(groupsEle, noNestGroupCallback, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (groupsEle.length &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var groupsIndex = 0; groupsIndex &lt; groupsEle.length; groupsIndex++) &#123;</span><br><span class="line">            // 如果文件夹名包含特定的字符，就直接合并该文件夹</span><br><span class="line">            <span class="keyword">if</span> (judgeIncludeText(ISBG, groupsEle[groupsIndex].name)) &#123;</span><br><span class="line">                getNeedMergeGroup(groupsEle[groupsIndex]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                doFindNestGroup(groupsEle[groupsIndex], findNestGroup, noNestGroupCallback, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 执行遍历组</span><br><span class="line"><span class="keyword">function</span> doFindNestGroup(groupEle, hasNestGroupCallback, noNestGroupCallback, callback) &#123;</span><br><span class="line">    //  如果组里有组</span><br><span class="line">    <span class="keyword">if</span> (groupEle.layerSets.length &gt; 0) &#123;</span><br><span class="line">        !!hasNestGroupCallback &amp;&amp; hasNestGroupCallback instanceof Function ? hasNestGroupCallback(groupEle.layerSets, noNestGroupCallback, callback) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        !!noNestGroupCallback &amp;&amp; noNestGroupCallback instanceof Function ? noNestGroupCallback(groupEle) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;!!callback &amp;&amp; callback instanceof Function ? callback(groupEle) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取需要合并的组</span><br><span class="line"><span class="keyword">function</span> getNeedMergeGroup(ele) &#123;</span><br><span class="line">    mergeGroupArr.push(ele);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 合并组</span><br><span class="line"><span class="keyword">function</span> mergeGroup(groupArr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i <span class="keyword">in</span> groupArr) &#123;</span><br><span class="line">        groupArr[i].merge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并完之后，问题来了，因为小编只合并了最小的组，其他组没有合并，也就是说，图层还在组里。在ps的编辑界面里面是有取消编组的按钮操作的，但小编在api里面没发现，所以之后遍历把图层移出组，最后再把所有组删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 处理图层</span><br><span class="line"><span class="keyword">function</span> dealLayer(groups) &#123;</span><br><span class="line">    ...</span><br><span class="line">    // 寻找组中需要移动的图层</span><br><span class="line">    findNestGroup(app.activeDocument.layerSets, getMoveLayer, getMoveLayer);</span><br><span class="line">    // 移动图层</span><br><span class="line">    moveLayer(moveLayerArr);</span><br><span class="line">    // 删除所有组</span><br><span class="line">    app.activeDocument.layerSets.removeAll();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 获取需要移动的图层</span><br><span class="line"><span class="keyword">function</span> getMoveLayer(groupEle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (groupEle.layers.length &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var layerNum = 0; layerNum &lt; groupEle.layers.length; layerNum++) &#123;</span><br><span class="line">            // 如果不是组，就把图层移出去</span><br><span class="line">            <span class="keyword">if</span> (groupEle.layers[layerNum].typename !== <span class="string">&#x27;layerSet&#x27;</span>) &#123;</span><br><span class="line">                moveLayerArr.push(groupEle.layers[layerNum]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 移动图层</span><br><span class="line"><span class="keyword">function</span> moveLayer(layerArr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var i <span class="keyword">in</span> layerArr) &#123;</span><br><span class="line">        // 对特殊的图层进行栅格化</span><br><span class="line">        // 文字图层</span><br><span class="line">        <span class="keyword">if</span> (layerArr[i].kind == <span class="string">&#x27;LayerKind.TEXT&#x27;</span>) &#123;</span><br><span class="line">            layerArr[i].rasterize(RasterizeType.TEXTCONTENTS);</span><br><span class="line">            layerArr[i].name = <span class="string">&#x27;text&#x27;</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">        // 形状图层</span><br><span class="line">        <span class="keyword">if</span> (layerArr[i].kind == <span class="string">&#x27;LayerKind.SOLIDFILL&#x27;</span>) &#123;</span><br><span class="line">            layerArr[i].rasterize(RasterizeType.FILLCONTENT);</span><br><span class="line">        &#125;</span><br><span class="line">        layerArr[i].move(app.activeDocument.layers[0], ElementPlacement.PLACEBEFORE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤三：导出图片<br>剩下这步主要就是ps脚本的api的运用。大家可以看下面的代码，都有详细的注释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">// 当前文档所有图层</span><br><span class="line">var layers = app.activeDocument.layers;</span><br><span class="line">// 当前文档</span><br><span class="line">var doc = app.activeDocument;</span><br><span class="line">// 创建新文档，尺寸为内存的图层大小</span><br><span class="line">app.documents.add(doc.width, doc.height, 72, <span class="string">&#x27;myDocument&#x27;</span>, NewDocumentMode.RGB, DocumentFill.TRANSPARENT);</span><br><span class="line">// 遍历所有图层</span><br><span class="line"><span class="keyword">for</span> (var i = 0; i &lt; layers.length; i++) &#123;</span><br><span class="line">    // 将target重置到设计稿文档</span><br><span class="line">    app.activeDocument = doc;</span><br><span class="line">    // 保存图层名称  </span><br><span class="line">    var layerName = layers[i].name;</span><br><span class="line">    // 将图层拷贝到内存</span><br><span class="line">    layers[i].copy();</span><br><span class="line">    // 获取图层大小</span><br><span class="line">    var bounds = layers[i].bounds;</span><br><span class="line">    // 宽度</span><br><span class="line">    var width = bounds[2] - bounds[0];</span><br><span class="line">    // 高度</span><br><span class="line">    var height = bounds[3] - bounds[1];</span><br><span class="line">    // 判断是否超出宽高度</span><br><span class="line">    var realWidth = width &gt; doc.width ? doc.width : width;</span><br><span class="line">    var realHeight = height &gt; doc.height ? doc.height : height;</span><br><span class="line">    // 将target重置到输出文档</span><br><span class="line">    app.activeDocument = app.documents[1];</span><br><span class="line">    // 重置图片大小</span><br><span class="line">    app.activeDocument.resizeCanvas(realWidth, realHeight, AnchorPosition.MIDDLECENTER);</span><br><span class="line">    // 创建新图层</span><br><span class="line">    app.activeDocument.artLayers.add();</span><br><span class="line">    // 将内存中的图层拷贝到新文档</span><br><span class="line">    app.activeDocument.paste();</span><br><span class="line">    // 获取图片格式配置</span><br><span class="line">    var photoType = judgeIncludeText(ISBG, layerName) ? getJPEGFormat() : getPNGFormat();</span><br><span class="line">    // 图片输出路径及文件名</span><br><span class="line">    var file = new File(outputFolder + <span class="string">&#x27;/&#x27;</span> + layerName + <span class="string">&#x27;.&#x27;</span> + photoType.type);</span><br><span class="line">    // 导出文件</span><br><span class="line">    app.activeDocument.exportDocument(file, ExportType.SAVEFORWEB, photoType.format);</span><br><span class="line">    // 将Photoshop的当前图层从图层列表中删除。</span><br><span class="line">    app.activeDocument.activeLayer.remove();</span><br><span class="line">&#125;</span><br><span class="line">// 关闭新文档（不存储）</span><br><span class="line">app.activeDocument.close(SaveOptions.DONOTSAVECHANGES);</span><br><span class="line"> </span><br><span class="line">// 获取PNG图片格式配置</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getPNGFormat</span></span>() &#123;</span><br><span class="line">    // 相当于【储存为web格式】</span><br><span class="line">    var option = new ExportOptionsSaveForWeb();</span><br><span class="line">    // 支持透明度</span><br><span class="line">    option.transparency = <span class="literal">true</span>;</span><br><span class="line">    // 色彩范围</span><br><span class="line">    option.colors = 256;</span><br><span class="line">    // 格式</span><br><span class="line">    option.format = SaveDocumentType.PNG;</span><br><span class="line">    // 不用png8格式压缩</span><br><span class="line">    option.PNG8 = <span class="literal">false</span>;</span><br><span class="line">    // 质量</span><br><span class="line">    option.quality = 80;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        format: option,</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">&#x27;png&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 获取jpeg图片格式配置</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">getJPEGFormat</span></span>() &#123;</span><br><span class="line">    var option = new ExportOptionsSaveForWeb();</span><br><span class="line">    // 色彩范围</span><br><span class="line">    option.colors = 256;</span><br><span class="line">    // 格式</span><br><span class="line">    option.format = SaveDocumentType.JPEG;</span><br><span class="line">    // 质量</span><br><span class="line">    option.quality = 75;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">        format: option,</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">&#x27;jpeg&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="想想问题"><a href="#想想问题" class="headerlink" title="想想问题"></a>想想问题</h4><p>1、这个小工具固然是方便的，但是却很以来psd的质量。所以如果要投入生产的话需要美术大大的配合，且开发人员也需在跑脚本前检查一遍。不过相对于手动切图，检查的时间还是非常少的。</p><p>2、这版本的小工具其实还有很多地方可以改进，比如说没有对图层的命名做处理，没有对同名图片覆盖的情况做处理等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;为什么会做这个呢？大概是因为小编我是一个“懒”到不想切图的程序员吧……某一天听说隔壁部门的大佬有这个想法，然后就自己也摆弄一下下。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="资源工具" scheme="https://www.37oct.cn/categories/%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="资源工具" scheme="https://www.37oct.cn/tags/%E8%B5%84%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
    <category term="ps自动切图" scheme="https://www.37oct.cn/tags/ps%E8%87%AA%E5%8A%A8%E5%88%87%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>当我们谈论React时，我们谈论些什么？</title>
    <link href="https://www.37oct.cn/2021/02/20/what-is-react/"/>
    <id>https://www.37oct.cn/2021/02/20/what-is-react/</id>
    <published>2021-02-20T06:40:05.000Z</published>
    <updated>2021-03-11T06:10:42.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>当我们谈论react，我们会谈论些什么？或许你没用过react，但是你应该或多或少听过一些关于react的名词：虚拟DOM，differ算法，生命周期等。这些名词究竟是什么意思，看完本文，希望你会有答案。</p></blockquote><h1 id="一、react-是什么？"><a href="#一、react-是什么？" class="headerlink" title="一、react 是什么？"></a>一、react 是什么？</h1><p>React是一个构造可组合式用户界面的库。它鼓励创建可重用的UI组件显示会随着时间而改变的数据。</p><h1 id="二、react设计的特点"><a href="#二、react设计的特点" class="headerlink" title="二、react设计的特点?"></a>二、react设计的特点?</h1><p>1、<strong>组件化</strong>的思想，将UI上功能相对独立的模块定义成组件，将小的组件通过组合或嵌套构造成大的组件，完成整体UI的构建，这意味着组件是高度可重用的。</p><p>2、<strong>虚拟DOM</strong>和<strong>数据单向绑定机制</strong>决定了react的响应很快。</p><p>3、并非一个完整的MVVM框架，它是一个纯V层框架，需要数据流的支撑（例如Redux）处理行为对应的响应。</p><h1 id="三、react为什么响应快？"><a href="#三、react为什么响应快？" class="headerlink" title="三、react为什么响应快？"></a>三、react为什么响应快？</h1><p>假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示</p><p><img src="/images/2021/what-is-react/pasted-0.png" alt="upload successful"><center><font color="#777" size="3">图3-1：例子</font></center><br>我们主要从<strong>状态维护</strong>和<strong>视图更新</strong>去看看MVC模式和MVVM模式实现的思路：</p><ul><li><strong>MVC</strong>: 给表格头部加点击事件，用户的点击特定的表头，对比表格里面的内容进行排序,然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。随着表格越来越复杂，需要进行监听的事件及更新dom的操作越来越多，代码难以维护。</li><li><strong>MVVM</strong>: 模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图，大大降低维护状态 -&gt; 视图的复杂程度。一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视，但是这样一来，即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低，对于大型视图来说，更是不可取。 </li><li><strong>React</strong>: 在维护状态这方面上，react也是mvvm的做法，但是在更新视图层上，react另辟蹊径，使用了Virtual DOM，加了一些特别的步骤来避免了整棵 DOM 树变更。</li></ul><p><strong><font color="red">虚拟DOM算法是React性能优于其它框架的关键因素</font>，那么什么是虚拟DOM? 怎么用虚拟Dom算法实现Dom树的更新？我们有必要从React的生命周期聊起。</strong></p><h1 id="四、react的状态更新"><a href="#四、react的状态更新" class="headerlink" title="四、react的状态更新"></a>四、react的状态更新</h1><h2 id="4-1-何时触发组件状态更新？"><a href="#4-1-何时触发组件状态更新？" class="headerlink" title="4.1 何时触发组件状态更新？"></a>4.1 何时触发组件状态更新？</h2><p>和vue类似的，React组件的生命周期分成三个状态： Mounting，Updating和Unmounting。</p><ol><li><p> <strong>Mounting</strong>：组件被render解析生成对于DOM节点并插入浏览器DOM结构的过程</p></li><li><p> <strong>Updating</strong>：一个已经mouted的组件被重新render的过程。</p></li><li><p> <strong>Unmounting</strong>：一个已经mouted的组件被从DOM结构中移除的过程。</p></li></ol><p>每个状态，React都封装了对应的钩子函数，如下图：<br><img src="/images/2021/what-is-react/pasted-1.png" alt="upload successful"></p><center><font color="#777" size="3">图4-1：组件生命周期钩子函数</font></center>我们关心组件状态的更新过程，发生在Updating这个过程。<p>如上，当state和props发生变化时，会来到图中的函数①接受到变化，函数②会判断组件是否需要更新（如图红色方框）：</p><p>组件不需要更新：函数②返回false，终止掉Updating的过程，</p><p>组件需要更新：函数②返回true，继续触发钩子函数③，进行重新render()，更新视图。</p><p><strong>在这个过程，react是如何判读组件是否需要更新的？下面将隆重请出我们的Virtual DOM算法出场。</strong></p><h2 id="4-2-为什么使用Virtual-DOM"><a href="#4-2-为什么使用Virtual-DOM" class="headerlink" title="4.2 为什么使用Virtual DOM"></a>4.2 为什么使用Virtual DOM</h2><p>事实上，DOM是很慢的，如果我们把一个简单元素DIV的属性都打印出来，可以看到有这么多东西：</p><p><img src="/images/2021/what-is-react/pasted-2.png" alt="upload successful"><center><font color="#777" size="3">图4-2：Dom元素属性信息</font></center><br>这一坨密密麻麻的属性说明了什么？说明了，DOM 元素非常庞大。这意味着，当一个页面的Dom结构比较复杂的时候，操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。</p><p>相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来。</p><p>以下代码片段是用Javascript对象表示一个列表的属性及节点的信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> element = &#123;</span><br><span class="line">  tagName: <span class="string">&#x27;ul&#x27;</span>, <span class="comment">// 节点标签名</span></span><br><span class="line">  props: &#123; <span class="comment">// DOM的属性，用一个对象存储键值对</span></span><br><span class="line">    id: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ <span class="comment">// 该节点的子节点</span></span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="attr">children</span>: [<span class="string">&quot;Item 1&quot;</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="attr">children</span>: [<span class="string">&quot;Item 2&quot;</span>]&#125;,</span><br><span class="line">    &#123;<span class="attr">tagName</span>: <span class="string">&#x27;li&#x27;</span>, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span>&#125;, <span class="attr">children</span>: [<span class="string">&quot;Item 3&quot;</span>]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Virtual DOM 算法的原理主要包括以下步骤：<br>    1. 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中。<br>    2. 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。<br>    3. 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。</p><p>本质就是，在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存。<br>    既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM），如图：<br>    <br><img src="/images/2021/what-is-react/pasted-3.png" alt="upload successful"><center><font color="#777" size="3">图4-2：虚拟Dom的作用</font></center><br>上面说的步骤一与步骤三不难理解，问题是Virtual DOM如何对比新的树和旧的树的差异呢？这是Virtual DOM最核心的部分—differ算法。</p><h2 id="4-3-differ算法"><a href="#4-3-differ算法" class="headerlink" title="4.3 differ算法"></a>4.3 differ算法</h2><p>前面我们说过，React的应用是由众多组件组合或嵌套构建起来的完整的树。所以，比较要比较新树和旧树的差异，就可以从三个层面来比较：</p><ul><li>树之间的差异：Tree differ</li><li>组件之间的差异：Component diff</li><li>组件内的差异：Element diff</li></ul><h3 id="4-3-1-Tree-differ"><a href="#4-3-1-Tree-differ" class="headerlink" title="4.3.1 Tree differ"></a>4.3.1 Tree differ</h3><p>   计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题.传统 diff 算法通过循环递归对节点进行依次对比,算法复杂度达到 O(n^3),其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。这种指数型的性能消耗对于前端渲染场景来说代价太高了！ CPU 每秒钟能执行大约30亿条指令，即便是最高效的实现，也不可能在一秒内计算出差异情况。</p><p>  由于Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计，所以React制定大胆的策略：<font color="red"><strong>干脆忽略跨层级的比较，两棵树只会对同一层次的节点进行比较</strong>。</font>如下图：      </p><p><img src="/images/2021/what-is-react/pasted-5.png" alt="upload successful"></p><center><font color="#777" size="3">图4-3：只对比同级的差异</font></center>只会对相同颜色方框内的 DOM 节点进行比较。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。<p>   <strong><em>但是如果出现了 DOM 节点跨层级的移动操作，如下图，A节点（第二层）被移动了D节点下面（第三层）React diff 会有怎样的表现呢？</em></strong><br>  <br><img src="/images/2021/what-is-react/pasted-6.png" alt="upload successful"><center><font color="#777" size="3">图4-3：跨层级差异</font></center><br>当根节点发现子节点中 A 消失了，就会直接销毁 A；当 D 发现多了一个子节点 A，则会创建新的 A（包括子节点）作为其子节点。此时，React diff 的执行情况：<br><strong>create A -&gt; create B -&gt; create C -&gt; delete A</strong><br> 由此可发现：当出现节点跨层级移动时，并不会出现想象中的移动操作，而是以 A 为根节点的树被整个重新创建，这是一种影响 React 性能的操作，因此 React 官方建议不要进行 DOM 节点跨层级的操作。</p><p>   注意：<font color="red"><strong>在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。</strong></font></p><h3 id="4-3-2-Component-diff"><a href="#4-3-2-Component-diff" class="headerlink" title="4.3.2 Component diff"></a>4.3.2 Component diff</h3><p> React 对于组件间的比较所采取的策略如下：</p><pre><code> 如果是相同组件，进一步比较** 组件内的元素**是否发生变化（Element diff）。 如果不是相同组件，则将该组件判断为 dirty component，从而** 替换整个组件下的所有子节点** 。</code></pre><p> 如图，左边树的D组件换成了右边新树的G组件，React直接替换掉D组件的所有节点。<br>  <br><img src="/images/2021/what-is-react/pasted-7.png" alt="upload successful"><center><font color="#777" size="3">图4-3：不同组件的差异策略</font></center></p><h4 id="4-3-2-2-Element-diff"><a href="#4-3-2-2-Element-diff" class="headerlink" title="4.3.2.2 Element diff"></a>4.3.2.2 Element diff</h4><pre><code>  当节点处于同一层级时，React diff 提供了三种节点操作：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。</code></pre><p>   插入与删除很好理解，如下图，老集合中包含节点：A、B、C、D，更新后的新集合中包含节点：B、A、D、C。<br>  <br><img src="/images/2021/what-is-react/pasted-8.png" alt="upload successful"><center><font color="#777" size="3">图4-2：插入和删除</font></center><br> 此时新老集合进行 diff 差异化对比，发现 B != A，则创建并插入 B 至新集合，删除老集合 A；以此类推，创建并插入 A、D 和 C，删除 B、C 和 D。</p><p>  React 发现这类操作繁琐冗余，因为这些都是相同的节点，但由于位置发生变化，导致需要进行繁杂低效的删除、创建操作，其实只要对这些节点进行位置移动即可。针对这一现象，React 提出优化策略：</p><pre><code> 对同一层级的同组子节点，添加唯一 key 进行区分。</code></pre><p>   新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。</p><p>   新老集合所包含的节点，如下图所示，新老集合进行 diff 差异化对比，通过 key 发现新老集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 React 给出的 diff 结果为：B、D 不做任何操作，A、C 进行移动操作，即可。<br><img src="/images/2021/what-is-react/pasted-9.png" alt="upload successful"><center><font color="#777" size="3">图4-2：移动操作</font></center></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p> 以上，就是关于React虚拟Dom及Differ算法的简单介绍。总而言之， 虚拟Dom的原理就是先用JavaScript表示Dom结构（实际中是使用React提供的语法糖JSX来写），构建出一颗真正的Dom树插入文档中。当Dom树发生变化时，React会重新构造一个新的虚拟树，将新树和旧树做对比，有差异则重新渲染视图。好了，通过这么一番介绍，你是否对一些关于React的名词有了进一步的认识呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;当我们谈论react，我们会谈论些什么？或许你没用过react，但是你应该或多或少听过一些关于react的名词：虚</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://www.37oct.cn/categories/JavaScript/"/>
    
    
    <category term="React" scheme="https://www.37oct.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>不好意思，观察者模式跟发布订阅模式就是不一样</title>
    <link href="https://www.37oct.cn/2021/02/20/observer-and-publishers/"/>
    <id>https://www.37oct.cn/2021/02/20/observer-and-publishers/</id>
    <published>2021-02-20T06:29:00.000Z</published>
    <updated>2021-03-11T06:10:42.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>一天，小猪佩奇去了一家西餐厅，点了一份西冷牛扒，还叫了圣女果。后来服务员上了一碟番茄，佩奇小姐：这是你的「圣女果」。佩奇猪一眼就看出了猫腻：这tm是番茄，不是圣女果啊！于是就跟服务员理论起来：这是番茄不是圣女果，不是！服务员一脸懵逼：番茄不就是圣女果吗？…佩奇猪一脸「黑人问号」了：番茄是菜，圣女果是水果，这能一样？？？</p><hr><p>观察者模式与发布/订阅模式大概就跟番茄与圣女果的关系一样，剪不断理还乱。也许，我们也听过两种模式之间的一些区别，但我相信，大部分的人对其中差异的感知还是很弱的。在JavaScript里，Observer模式通常被我们用Publish/Subscribe模式来实现，不可否认这些模式很相似，但它们还是有很本质的区别！</p><h3 id="二、观察者模式与发布-订阅模式的区别"><a href="#二、观察者模式与发布-订阅模式的区别" class="headerlink" title="二、观察者模式与发布/订阅模式的区别"></a>二、观察者模式与发布/订阅模式的区别</h3><p>通过一张图来宏观了解差异：<br><img src="/images/2021/observer-and-publishers/1.jpg"></p><h4 id="1、对观察者模式的理解"><a href="#1、对观察者模式的理解" class="headerlink" title="1、对观察者模式的理解"></a>1、对观察者模式的理解</h4><blockquote><p>观察者模式：一个对象（称为<font color="#42b983">subject</font>）维持一系列依赖于它的对象（称为<font color="#42b983">observer</font>），将有关状态的任何变更自动通知给它们（观察者）。</p></blockquote><h4 id="2、对发布-订阅模式的理解"><a href="#2、对发布-订阅模式的理解" class="headerlink" title="2、对发布/订阅模式的理解"></a>2、对发布/订阅模式的理解</h4><blockquote><p>发布/订阅模式：基于一个主题/事件通道，希望接收通知的对象（称为<font color="#42b983">subscriber</font>）通过自定义事件订阅主题，被激活事件的对象（称为<font color="#42b983">publisher</font>）通过发布主题事件的方式被通知。</p></blockquote><h4 id="3、两种模式之间的差异"><a href="#3、两种模式之间的差异" class="headerlink" title="3、两种模式之间的差异"></a>3、两种模式之间的差异</h4><ul><li>Observer模式要求观察者必须订阅内容改变的事件，定义了一个<font color="#42b983">一对多</font>的依赖关系；</li><li>Publish/Subscribe模式使用了一个<font color="#42b983">主题/事件通道</font>，这个通道介于订阅着与发布者之间；</li><li>观察者模式里面观察者「被迫」执行内容改变事件（subject内容事件）；发布/订阅模式中，订阅着可以自定义事件处理程序；</li><li>观察者模式两个对象之间有很强的依赖关系；发布/订阅模式两个对象之间的耦合读底。</li></ul><h3 id="三、举个栗子"><a href="#三、举个栗子" class="headerlink" title="三、举个栗子"></a>三、举个栗子</h3><p>使用两个栗子形象解释两种模式应用上的差异，让你由内而外，自上而下，感知它的美妙！@佩奇猪的故事</p><h5 id="1、观察者模式的应用"><a href="#1、观察者模式的应用" class="headerlink" title="1、观察者模式的应用"></a>1、观察者模式的应用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为半伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义下观察者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定一个下目标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subscribe</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加观察者</span></span><br><span class="line">Subscribe.prototype.addObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标通知变更</span></span><br><span class="line">Subscribe.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个佩奇猪的观察者</span></span><br><span class="line"><span class="keyword">var</span> peikizhuObs = <span class="keyword">new</span> Observer();</span><br><span class="line">peikizhuObs.update = <span class="function"><span class="keyword">function</span>(<span class="params">what</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;12 o&#x27;clock! 佩奇猪想要&quot;</span> + what);</span><br><span class="line">&#125;</span><br><span class="line">Subscribe.addObserver(peikizhuObs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个皮卡丘的观察者</span></span><br><span class="line"><span class="keyword">var</span> pikachuObs = <span class="keyword">new</span> Observer();</span><br><span class="line">pikachuObs.update = <span class="function"><span class="keyword">function</span>(<span class="params">what</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;皮卡丘还可以做一点自己比较个性的事情，但是12点我也是要去吃饭的！&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;12 o&#x27;clock! 皮卡丘想要&quot;</span> + what);</span><br><span class="line">&#125;</span><br><span class="line">Subscribe.addObserver(pikachuObs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假装12点到了</span></span><br><span class="line">Subscribe.notify(<span class="string">&#x27;去吃饭啦～&#x27;</span>);  <span class="comment">// 它们都去吃饭了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">Subscribe.notify(<span class="string">&#x27;继续玩耍～&#x27;</span>);  <span class="comment">// 它们还在一起玩耍</span></span><br></pre></td></tr></table></figure><p><font color="#f66"><strong>说明：</strong></font>可以看出，每一个observer虽然也可以自定义自己的处理程序（<font color="#e96900">update</font>方法），但是<font color="#42b983">观察者模式下，观察者们都是做同一类的事情的</font>。</p><h5 id="2、发布-订阅模式的应用"><a href="#2、发布-订阅模式的应用" class="headerlink" title="2、发布/订阅模式的应用"></a>2、发布/订阅模式的应用</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下为半伪代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简易的发布订阅</span></span><br><span class="line"><span class="keyword">var</span> pubsub = &#123;</span><br><span class="line">    subscribe: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    </span><br><span class="line">    publish: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 佩奇猪：我要订阅一个「12点」的主题事件，提醒我继续工作</span></span><br><span class="line">pubsub.subscribe(<span class="string">&quot;12 o&#x27;clock&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(who + <span class="string">&#x27;要继续工作！这就是为什么本猪上了屏幕，而你们上了餐桌。&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 皮卡丘：我也要订阅一个「12点」的主题事件，提醒我去吃饭</span></span><br><span class="line">pubsub.subscribe(<span class="string">&quot;12 o&#x27;clock&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">who</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(who + <span class="string">&#x27;要吃饭，去它的工作！&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假装12点到了</span></span><br><span class="line">pubsub.publish(<span class="string">&quot;12 o&#x27;clock&quot;</span>,<span class="string">&#x27;PeikiZhu&#x27;</span>);</span><br><span class="line">pubsub.publish(<span class="string">&quot;12 o&#x27;clock&quot;</span>,<span class="string">&#x27;PiKaChu&#x27;</span>);</span><br></pre></td></tr></table></figure><p><font color="#f66"><strong>说明：</strong></font>如你所见，发布/订阅模式，订阅的是订阅者各自不同逻辑的处理程序，类比下jQuery订阅点击事件。</p><h3 id="四、从实现方式上理解差异"><a href="#四、从实现方式上理解差异" class="headerlink" title="四、从实现方式上理解差异"></a>四、从实现方式上理解差异</h3><p>那么，到了这里，有没有比较有feel了？有没有get到那个…只可意会不可言传的点？</p><p>还是没有？？？</p><p>原谅在下不善言辞，只想丢段代码给你。从实现方式上看两者的不同</p><h5 id="1、实现观察者模式"><a href="#1、实现观察者模式" class="headerlink" title="1、实现观察者模式"></a>1、实现观察者模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式组件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author  <span class="variable">wilton</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObserverList</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">this</span>.observerLists = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加观察者对象</span></span><br><span class="line">ObserverList.prototype.add = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保证observer的唯一性</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.observerLists.indexOf(obj) != -<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">this</span>.observerLists;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.observerLists.push(obj);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空观察者对象</span></span><br><span class="line">ObserverList.prototype.empty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.observerLists = [];</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算当前的观察者数量</span></span><br><span class="line">ObserverList.prototype.count = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.observerLists.length;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出对应编号的观察者对象</span></span><br><span class="line">ObserverList.prototype.get = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt; -<span class="number">1</span> &amp;&amp; index &lt; <span class="built_in">this</span>.observerLists.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.observerLists[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定位置上插入观察者对象</span></span><br><span class="line">ObserverList.prototype.insert = <span class="function"><span class="keyword">function</span>(<span class="params">obj,index</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> pointer = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.observerLists.unshift(obj);</span><br><span class="line">pointer = index;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.observerLists.length) &#123;</span><br><span class="line"><span class="built_in">this</span>.observerLists.push(obj);</span><br><span class="line">pointer = index;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.observerLists.splice(index, <span class="number">0</span>, obj);</span><br><span class="line">pointer = index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pointer;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找观察者对象所在的位置编号</span></span><br><span class="line">ObserverList.prototype.indexOf = <span class="function"><span class="keyword">function</span>(<span class="params">obj, startIndex</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> i = startIndex || <span class="number">0</span>, pointer = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="built_in">this</span>.observerLists.length) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.observerLists[i] === obj) &#123;</span><br><span class="line">pointer = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pointer;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除指定编号的观察者</span></span><br><span class="line">ObserverList.prototype.removeIndexAt = <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> temp = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">temp = <span class="built_in">this</span>.observerLists.shift();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="built_in">this</span>.observerLists.length) &#123;</span><br><span class="line">temp = <span class="built_in">this</span>.observerLists.pop();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">temp = <span class="built_in">this</span>.observerLists.splice(index, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义目标类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Subject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.observers = <span class="keyword">new</span> ObserverList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加观察者</span></span><br><span class="line">Subject.prototype.addObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.observers.add(observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除观察者</span></span><br><span class="line">Subject.prototype.removeObserver = <span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.observers.removeIndexAt(<span class="built_in">this</span>.observers.indexOf(observer, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知观察者</span></span><br><span class="line">Subject.prototype.notify = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> observersCount = <span class="built_in">this</span>.observers.count();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; observersCount; i++)&#123;</span><br><span class="line"><span class="built_in">this</span>.observers.get(i).update(params);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义观察者内容更新事件</span></span><br><span class="line"><span class="built_in">this</span>.update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">Observer: Observer,</span><br><span class="line">Subject: Subject,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象扩展</span></span><br><span class="line">extend: <span class="function"><span class="keyword">function</span>(<span class="params">obj, extension</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">extension[key] = obj[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><a href="https://github.com/qiudongwei/pattern-struct/tree/master/ObserverPattern">github-ObserverPattern</a></p><h5 id="2、实现发布-订阅模式"><a href="#2、实现发布-订阅模式" class="headerlink" title="2、实现发布/订阅模式"></a>2、实现发布/订阅模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布/订阅模式组件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author  <span class="variable">wilton</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义发布/订阅类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pubsub</span> </span>&#123;</span><br><span class="line"><span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line"><span class="built_in">this</span>.topics = &#123;&#125;;</span><br><span class="line"><span class="built_in">this</span>.subUid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line">publish (topic, args) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.topics[topic]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> subscribers = <span class="built_in">this</span>.topics[topic];</span><br><span class="line"><span class="keyword">let</span> len = subscribers ? subscribers.length : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (len--) &#123;</span><br><span class="line">subscribers[len].func(topic, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅事件</span></span><br><span class="line">subscribe (topic,func) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.topics[topic]) <span class="built_in">this</span>.topics[topic] = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> token = (++<span class="built_in">this</span>.subUid).toString();</span><br><span class="line"><span class="built_in">this</span>.topics[topic].push(&#123;</span><br><span class="line">token: token,</span><br><span class="line">func: func</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">unsubscribe (token) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> m <span class="keyword">in</span> topics) &#123;</span><br><span class="line"><span class="keyword">if</span> (topics[m]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; topics[m].length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (topics[m][i].token == token) &#123;</span><br><span class="line">topics[m].splice(i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Pubsub;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/qiudongwei/pattern-struct/tree/master/PubsubPattern">github-PubsubPattern</a></p><h3 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h3><p>以上观点只是个人结合实践产出的理解，欢迎各位过路的大佬补充斧正～</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h3&gt;&lt;p&gt;一天，小猪佩奇去了一家西餐厅，点了一份西冷牛扒，还叫了圣女果。后来服务员上了一碟番茄，佩奇小姐：这是你的「圣女果」。佩奇猪一</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://www.37oct.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://www.37oct.cn/tags/JavaScript/"/>
    
  </entry>
  
</feed>
